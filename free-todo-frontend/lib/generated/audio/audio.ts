/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * LifeTrace API
 * æ™ºèƒ½ç”Ÿæ´»è®°å½•ç³»ç»Ÿ API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AudioLinkRequest,
  ExtractTodosAndSchedulesApiAudioExtractPostParams,
  GetRecordingsApiAudioRecordingsGetParams,
  GetTimelineApiAudioTimelineGetParams,
  GetTranscriptionApiAudioTranscriptionRecordingIdGetParams,
  HTTPValidationError,
  LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostParams,
  OptimizeTranscriptionApiAudioOptimizePostParams
} from '.././schemas';

import { customFetcher } from '.././fetcher';




/**
 * èŽ·å–å½•éŸ³åˆ—è¡¨
 * @summary Get Recordings
 */
export const getRecordingsApiAudioRecordingsGet = (
    params?: GetRecordingsApiAudioRecordingsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<unknown>(
      {url: `/api/audio/recordings`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetRecordingsApiAudioRecordingsGetQueryKey = (params?: GetRecordingsApiAudioRecordingsGetParams,) => {
    return [
    `/api/audio/recordings`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetRecordingsApiAudioRecordingsGetQueryOptions = <TData = Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError = HTTPValidationError>(params?: GetRecordingsApiAudioRecordingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecordingsApiAudioRecordingsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>> = ({ signal }) => getRecordingsApiAudioRecordingsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecordingsApiAudioRecordingsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>>
export type GetRecordingsApiAudioRecordingsGetQueryError = HTTPValidationError


export function useGetRecordingsApiAudioRecordingsGet<TData = Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError = HTTPValidationError>(
 params: undefined |  GetRecordingsApiAudioRecordingsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>,
          TError,
          Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecordingsApiAudioRecordingsGet<TData = Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError = HTTPValidationError>(
 params?: GetRecordingsApiAudioRecordingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>,
          TError,
          Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecordingsApiAudioRecordingsGet<TData = Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError = HTTPValidationError>(
 params?: GetRecordingsApiAudioRecordingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Recordings
 */

export function useGetRecordingsApiAudioRecordingsGet<TData = Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError = HTTPValidationError>(
 params?: GetRecordingsApiAudioRecordingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingsApiAudioRecordingsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecordingsApiAudioRecordingsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æŒ‰æ—¥æœŸè¿”å›žå½•éŸ³æ—¶é—´çº¿ï¼ˆå«è½¬å½•æ–‡æœ¬ï¼‰
 * @summary Get Timeline
 */
export const getTimelineApiAudioTimelineGet = (
    params?: GetTimelineApiAudioTimelineGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<unknown>(
      {url: `/api/audio/timeline`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetTimelineApiAudioTimelineGetQueryKey = (params?: GetTimelineApiAudioTimelineGetParams,) => {
    return [
    `/api/audio/timeline`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetTimelineApiAudioTimelineGetQueryOptions = <TData = Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError = HTTPValidationError>(params?: GetTimelineApiAudioTimelineGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineApiAudioTimelineGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>> = ({ signal }) => getTimelineApiAudioTimelineGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTimelineApiAudioTimelineGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>>
export type GetTimelineApiAudioTimelineGetQueryError = HTTPValidationError


export function useGetTimelineApiAudioTimelineGet<TData = Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError = HTTPValidationError>(
 params: undefined |  GetTimelineApiAudioTimelineGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>,
          TError,
          Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelineApiAudioTimelineGet<TData = Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError = HTTPValidationError>(
 params?: GetTimelineApiAudioTimelineGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>,
          TError,
          Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelineApiAudioTimelineGet<TData = Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError = HTTPValidationError>(
 params?: GetTimelineApiAudioTimelineGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Timeline
 */

export function useGetTimelineApiAudioTimelineGet<TData = Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError = HTTPValidationError>(
 params?: GetTimelineApiAudioTimelineGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelineApiAudioTimelineGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTimelineApiAudioTimelineGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–å½•éŸ³æ–‡ä»¶ï¼ˆç”¨äºŽå‰ç«¯æ’­æ”¾ï¼‰
 * @summary Get Recording File
 */
export const getRecordingFileApiAudioRecordingRecordingIdFileGet = (
    recordingId: number,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<unknown>(
      {url: `/api/audio/recording/${recordingId}/file`, method: 'GET', signal
    },
      );
    }
  



export const getGetRecordingFileApiAudioRecordingRecordingIdFileGetQueryKey = (recordingId?: number,) => {
    return [
    `/api/audio/recording/${recordingId}/file`
    ] as const;
    }

    
export const getGetRecordingFileApiAudioRecordingRecordingIdFileGetQueryOptions = <TData = Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError = HTTPValidationError>(recordingId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecordingFileApiAudioRecordingRecordingIdFileGetQueryKey(recordingId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>> = ({ signal }) => getRecordingFileApiAudioRecordingRecordingIdFileGet(recordingId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(recordingId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecordingFileApiAudioRecordingRecordingIdFileGetQueryResult = NonNullable<Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>>
export type GetRecordingFileApiAudioRecordingRecordingIdFileGetQueryError = HTTPValidationError


export function useGetRecordingFileApiAudioRecordingRecordingIdFileGet<TData = Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError = HTTPValidationError>(
 recordingId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>,
          TError,
          Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecordingFileApiAudioRecordingRecordingIdFileGet<TData = Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError = HTTPValidationError>(
 recordingId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>,
          TError,
          Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecordingFileApiAudioRecordingRecordingIdFileGet<TData = Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError = HTTPValidationError>(
 recordingId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Recording File
 */

export function useGetRecordingFileApiAudioRecordingRecordingIdFileGet<TData = Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError = HTTPValidationError>(
 recordingId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecordingFileApiAudioRecordingRecordingIdFileGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecordingFileApiAudioRecordingRecordingIdFileGetQueryOptions(recordingId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–è½¬å½•æ–‡æœ¬
 * @summary Get Transcription
 */
export const getTranscriptionApiAudioTranscriptionRecordingIdGet = (
    recordingId: number,
    params?: GetTranscriptionApiAudioTranscriptionRecordingIdGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<unknown>(
      {url: `/api/audio/transcription/${recordingId}`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetTranscriptionApiAudioTranscriptionRecordingIdGetQueryKey = (recordingId?: number,
    params?: GetTranscriptionApiAudioTranscriptionRecordingIdGetParams,) => {
    return [
    `/api/audio/transcription/${recordingId}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetTranscriptionApiAudioTranscriptionRecordingIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError = HTTPValidationError>(recordingId: number,
    params?: GetTranscriptionApiAudioTranscriptionRecordingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTranscriptionApiAudioTranscriptionRecordingIdGetQueryKey(recordingId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>> = ({ signal }) => getTranscriptionApiAudioTranscriptionRecordingIdGet(recordingId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(recordingId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTranscriptionApiAudioTranscriptionRecordingIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>>
export type GetTranscriptionApiAudioTranscriptionRecordingIdGetQueryError = HTTPValidationError


export function useGetTranscriptionApiAudioTranscriptionRecordingIdGet<TData = Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError = HTTPValidationError>(
 recordingId: number,
    params: undefined |  GetTranscriptionApiAudioTranscriptionRecordingIdGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTranscriptionApiAudioTranscriptionRecordingIdGet<TData = Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError = HTTPValidationError>(
 recordingId: number,
    params?: GetTranscriptionApiAudioTranscriptionRecordingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTranscriptionApiAudioTranscriptionRecordingIdGet<TData = Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError = HTTPValidationError>(
 recordingId: number,
    params?: GetTranscriptionApiAudioTranscriptionRecordingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transcription
 */

export function useGetTranscriptionApiAudioTranscriptionRecordingIdGet<TData = Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError = HTTPValidationError>(
 recordingId: number,
    params?: GetTranscriptionApiAudioTranscriptionRecordingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscriptionApiAudioTranscriptionRecordingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTranscriptionApiAudioTranscriptionRecordingIdGetQueryOptions(recordingId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Mark extracted items as linked to todos (persisted in transcription JSON).

Args:
    recording_id: å½•éŸ³ID
    request: é“¾æŽ¥è¯·æ±‚
    optimized: æ˜¯å¦æ›´æ–°ä¼˜åŒ–æ–‡æœ¬çš„æå–ç»“æžœ
 * @summary Link Extracted Items
 */
export const linkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost = (
    recordingId: number,
    audioLinkRequest: AudioLinkRequest,
    params?: LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<unknown>(
      {url: `/api/audio/transcription/${recordingId}/link`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: audioLinkRequest,
        params, signal
    },
      );
    }
  


export const getLinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost>>, TError,{recordingId: number;data: AudioLinkRequest;params?: LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof linkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost>>, TError,{recordingId: number;data: AudioLinkRequest;params?: LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostParams}, TContext> => {

const mutationKey = ['linkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof linkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost>>, {recordingId: number;data: AudioLinkRequest;params?: LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostParams}> = (props) => {
          const {recordingId,data,params} = props ?? {};

          return  linkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost(recordingId,data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostMutationResult = NonNullable<Awaited<ReturnType<typeof linkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost>>>
    export type LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostMutationBody = AudioLinkRequest
    export type LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostMutationError = HTTPValidationError

    /**
 * @summary Link Extracted Items
 */
export const useLinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost>>, TError,{recordingId: number;data: AudioLinkRequest;params?: LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof linkExtractedItemsApiAudioTranscriptionRecordingIdLinkPost>>,
        TError,
        {recordingId: number;data: AudioLinkRequest;params?: LinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostParams},
        TContext
      > => {

      const mutationOptions = getLinkExtractedItemsApiAudioTranscriptionRecordingIdLinkPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * ä¼˜åŒ–è½¬å½•æ–‡æœ¬ï¼ˆä½¿ç”¨LLMï¼‰
 * @summary Optimize Transcription
 */
export const optimizeTranscriptionApiAudioOptimizePost = (
    params: OptimizeTranscriptionApiAudioOptimizePostParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<unknown>(
      {url: `/api/audio/optimize`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getOptimizeTranscriptionApiAudioOptimizePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof optimizeTranscriptionApiAudioOptimizePost>>, TError,{params: OptimizeTranscriptionApiAudioOptimizePostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof optimizeTranscriptionApiAudioOptimizePost>>, TError,{params: OptimizeTranscriptionApiAudioOptimizePostParams}, TContext> => {

const mutationKey = ['optimizeTranscriptionApiAudioOptimizePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof optimizeTranscriptionApiAudioOptimizePost>>, {params: OptimizeTranscriptionApiAudioOptimizePostParams}> = (props) => {
          const {params} = props ?? {};

          return  optimizeTranscriptionApiAudioOptimizePost(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OptimizeTranscriptionApiAudioOptimizePostMutationResult = NonNullable<Awaited<ReturnType<typeof optimizeTranscriptionApiAudioOptimizePost>>>
    
    export type OptimizeTranscriptionApiAudioOptimizePostMutationError = HTTPValidationError

    /**
 * @summary Optimize Transcription
 */
export const useOptimizeTranscriptionApiAudioOptimizePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof optimizeTranscriptionApiAudioOptimizePost>>, TError,{params: OptimizeTranscriptionApiAudioOptimizePostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof optimizeTranscriptionApiAudioOptimizePost>>,
        TError,
        {params: OptimizeTranscriptionApiAudioOptimizePostParams},
        TContext
      > => {

      const mutationOptions = getOptimizeTranscriptionApiAudioOptimizePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * æå–å¾…åŠžäº‹é¡¹å’Œæ—¥ç¨‹å®‰æŽ’

Args:
    recording_id: å½•éŸ³ID
    optimized: æ˜¯å¦ä»Žä¼˜åŒ–æ–‡æœ¬æå–ï¼ˆFalse=ä»ŽåŽŸæ–‡æå–ï¼‰
 * @summary Extract Todos And Schedules
 */
export const extractTodosAndSchedulesApiAudioExtractPost = (
    params: ExtractTodosAndSchedulesApiAudioExtractPostParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<unknown>(
      {url: `/api/audio/extract`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getExtractTodosAndSchedulesApiAudioExtractPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractTodosAndSchedulesApiAudioExtractPost>>, TError,{params: ExtractTodosAndSchedulesApiAudioExtractPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof extractTodosAndSchedulesApiAudioExtractPost>>, TError,{params: ExtractTodosAndSchedulesApiAudioExtractPostParams}, TContext> => {

const mutationKey = ['extractTodosAndSchedulesApiAudioExtractPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractTodosAndSchedulesApiAudioExtractPost>>, {params: ExtractTodosAndSchedulesApiAudioExtractPostParams}> = (props) => {
          const {params} = props ?? {};

          return  extractTodosAndSchedulesApiAudioExtractPost(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractTodosAndSchedulesApiAudioExtractPostMutationResult = NonNullable<Awaited<ReturnType<typeof extractTodosAndSchedulesApiAudioExtractPost>>>
    
    export type ExtractTodosAndSchedulesApiAudioExtractPostMutationError = HTTPValidationError

    /**
 * @summary Extract Todos And Schedules
 */
export const useExtractTodosAndSchedulesApiAudioExtractPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractTodosAndSchedulesApiAudioExtractPost>>, TError,{params: ExtractTodosAndSchedulesApiAudioExtractPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof extractTodosAndSchedulesApiAudioExtractPost>>,
        TError,
        {params: ExtractTodosAndSchedulesApiAudioExtractPostParams},
        TContext
      > => {

      const mutationOptions = getExtractTodosAndSchedulesApiAudioExtractPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    