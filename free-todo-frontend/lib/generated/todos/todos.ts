/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * LifeTrace API
 * æ™ºèƒ½ç”Ÿæ´»è®°å½•ç³»ç»Ÿ API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyImportIcsApiTodosImportIcsPost,
  ExportIcsApiTodosExportIcsGetParams,
  HTTPValidationError,
  ListTodosApiTodosGetParams,
  TodoCreate,
  TodoListResponse,
  TodoReorderRequest,
  TodoResponse,
  TodoUpdate
} from '.././schemas';

import { customFetcher } from '.././fetcher';




/**
 * èŽ·å–å¾…åŠžåˆ—è¡¨
 * @summary List Todos
 */
export const listTodosApiTodosGet = (
    params?: ListTodosApiTodosGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<TodoListResponse>(
      {url: `/api/todos`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListTodosApiTodosGetQueryKey = (params?: ListTodosApiTodosGetParams,) => {
    return [
    `/api/todos`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListTodosApiTodosGetQueryOptions = <TData = Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError = HTTPValidationError>(params?: ListTodosApiTodosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTodosApiTodosGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTodosApiTodosGet>>> = ({ signal }) => listTodosApiTodosGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListTodosApiTodosGetQueryResult = NonNullable<Awaited<ReturnType<typeof listTodosApiTodosGet>>>
export type ListTodosApiTodosGetQueryError = HTTPValidationError


export function useListTodosApiTodosGet<TData = Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError = HTTPValidationError>(
 params: undefined |  ListTodosApiTodosGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTodosApiTodosGet>>,
          TError,
          Awaited<ReturnType<typeof listTodosApiTodosGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTodosApiTodosGet<TData = Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError = HTTPValidationError>(
 params?: ListTodosApiTodosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTodosApiTodosGet>>,
          TError,
          Awaited<ReturnType<typeof listTodosApiTodosGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTodosApiTodosGet<TData = Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError = HTTPValidationError>(
 params?: ListTodosApiTodosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Todos
 */

export function useListTodosApiTodosGet<TData = Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError = HTTPValidationError>(
 params?: ListTodosApiTodosGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTodosApiTodosGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListTodosApiTodosGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * åˆ›å»ºå¾…åŠž
 * @summary Create Todo
 */
export const createTodoApiTodosPost = (
    todoCreate: TodoCreate,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<TodoResponse>(
      {url: `/api/todos`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: todoCreate, signal
    },
      );
    }
  


export const getCreateTodoApiTodosPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTodoApiTodosPost>>, TError,{data: TodoCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createTodoApiTodosPost>>, TError,{data: TodoCreate}, TContext> => {

const mutationKey = ['createTodoApiTodosPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTodoApiTodosPost>>, {data: TodoCreate}> = (props) => {
          const {data} = props ?? {};

          return  createTodoApiTodosPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTodoApiTodosPostMutationResult = NonNullable<Awaited<ReturnType<typeof createTodoApiTodosPost>>>
    export type CreateTodoApiTodosPostMutationBody = TodoCreate
    export type CreateTodoApiTodosPostMutationError = HTTPValidationError

    /**
 * @summary Create Todo
 */
export const useCreateTodoApiTodosPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTodoApiTodosPost>>, TError,{data: TodoCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTodoApiTodosPost>>,
        TError,
        {data: TodoCreate},
        TContext
      > => {

      const mutationOptions = getCreateTodoApiTodosPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * èŽ·å–å•ä¸ªå¾…åŠž
 * @summary Get Todo
 */
export const getTodoApiTodosTodoIdGet = (
    todoId: number,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<TodoResponse>(
      {url: `/api/todos/${todoId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetTodoApiTodosTodoIdGetQueryKey = (todoId?: number,) => {
    return [
    `/api/todos/${todoId}`
    ] as const;
    }

    
export const getGetTodoApiTodosTodoIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError = HTTPValidationError>(todoId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTodoApiTodosTodoIdGetQueryKey(todoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>> = ({ signal }) => getTodoApiTodosTodoIdGet(todoId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(todoId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTodoApiTodosTodoIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>>
export type GetTodoApiTodosTodoIdGetQueryError = HTTPValidationError


export function useGetTodoApiTodosTodoIdGet<TData = Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError = HTTPValidationError>(
 todoId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTodoApiTodosTodoIdGet<TData = Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError = HTTPValidationError>(
 todoId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTodoApiTodosTodoIdGet<TData = Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError = HTTPValidationError>(
 todoId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Todo
 */

export function useGetTodoApiTodosTodoIdGet<TData = Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError = HTTPValidationError>(
 todoId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodoApiTodosTodoIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTodoApiTodosTodoIdGetQueryOptions(todoId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æ›´æ–°å¾…åŠž
 * @summary Update Todo
 */
export const updateTodoApiTodosTodoIdPut = (
    todoId: number,
    todoUpdate: TodoUpdate,
 ) => {
      
      
      return customFetcher<TodoResponse>(
      {url: `/api/todos/${todoId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: todoUpdate
    },
      );
    }
  


export const getUpdateTodoApiTodosTodoIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTodoApiTodosTodoIdPut>>, TError,{todoId: number;data: TodoUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateTodoApiTodosTodoIdPut>>, TError,{todoId: number;data: TodoUpdate}, TContext> => {

const mutationKey = ['updateTodoApiTodosTodoIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTodoApiTodosTodoIdPut>>, {todoId: number;data: TodoUpdate}> = (props) => {
          const {todoId,data} = props ?? {};

          return  updateTodoApiTodosTodoIdPut(todoId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTodoApiTodosTodoIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateTodoApiTodosTodoIdPut>>>
    export type UpdateTodoApiTodosTodoIdPutMutationBody = TodoUpdate
    export type UpdateTodoApiTodosTodoIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Todo
 */
export const useUpdateTodoApiTodosTodoIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTodoApiTodosTodoIdPut>>, TError,{todoId: number;data: TodoUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTodoApiTodosTodoIdPut>>,
        TError,
        {todoId: number;data: TodoUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateTodoApiTodosTodoIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * åˆ é™¤å¾…åŠž
 * @summary Delete Todo
 */
export const deleteTodoApiTodosTodoIdDelete = (
    todoId: number,
 ) => {
      
      
      return customFetcher<void>(
      {url: `/api/todos/${todoId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTodoApiTodosTodoIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTodoApiTodosTodoIdDelete>>, TError,{todoId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteTodoApiTodosTodoIdDelete>>, TError,{todoId: number}, TContext> => {

const mutationKey = ['deleteTodoApiTodosTodoIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTodoApiTodosTodoIdDelete>>, {todoId: number}> = (props) => {
          const {todoId} = props ?? {};

          return  deleteTodoApiTodosTodoIdDelete(todoId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTodoApiTodosTodoIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTodoApiTodosTodoIdDelete>>>
    
    export type DeleteTodoApiTodosTodoIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Todo
 */
export const useDeleteTodoApiTodosTodoIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTodoApiTodosTodoIdDelete>>, TError,{todoId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTodoApiTodosTodoIdDelete>>,
        TError,
        {todoId: number},
        TContext
      > => {

      const mutationOptions = getDeleteTodoApiTodosTodoIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * æ‰¹é‡æ›´æ–°å¾…åŠžçš„æŽ’åºå’Œçˆ¶å­å…³ç³»
 * @summary Reorder Todos
 */
export const reorderTodosApiTodosReorderPost = (
    todoReorderRequest: TodoReorderRequest,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<unknown>(
      {url: `/api/todos/reorder`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: todoReorderRequest, signal
    },
      );
    }
  


export const getReorderTodosApiTodosReorderPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reorderTodosApiTodosReorderPost>>, TError,{data: TodoReorderRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof reorderTodosApiTodosReorderPost>>, TError,{data: TodoReorderRequest}, TContext> => {

const mutationKey = ['reorderTodosApiTodosReorderPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reorderTodosApiTodosReorderPost>>, {data: TodoReorderRequest}> = (props) => {
          const {data} = props ?? {};

          return  reorderTodosApiTodosReorderPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReorderTodosApiTodosReorderPostMutationResult = NonNullable<Awaited<ReturnType<typeof reorderTodosApiTodosReorderPost>>>
    export type ReorderTodosApiTodosReorderPostMutationBody = TodoReorderRequest
    export type ReorderTodosApiTodosReorderPostMutationError = HTTPValidationError

    /**
 * @summary Reorder Todos
 */
export const useReorderTodosApiTodosReorderPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reorderTodosApiTodosReorderPost>>, TError,{data: TodoReorderRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reorderTodosApiTodosReorderPost>>,
        TError,
        {data: TodoReorderRequest},
        TContext
      > => {

      const mutationOptions = getReorderTodosApiTodosReorderPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * å¯¼å‡º Todo ä¸º ICS æ–‡ä»¶
 * @summary Export Ics
 */
export const exportIcsApiTodosExportIcsGet = (
    params?: ExportIcsApiTodosExportIcsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<unknown>(
      {url: `/api/todos/export/ics`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getExportIcsApiTodosExportIcsGetQueryKey = (params?: ExportIcsApiTodosExportIcsGetParams,) => {
    return [
    `/api/todos/export/ics`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getExportIcsApiTodosExportIcsGetQueryOptions = <TData = Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError = HTTPValidationError>(params?: ExportIcsApiTodosExportIcsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExportIcsApiTodosExportIcsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>> = ({ signal }) => exportIcsApiTodosExportIcsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExportIcsApiTodosExportIcsGetQueryResult = NonNullable<Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>>
export type ExportIcsApiTodosExportIcsGetQueryError = HTTPValidationError


export function useExportIcsApiTodosExportIcsGet<TData = Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError = HTTPValidationError>(
 params: undefined |  ExportIcsApiTodosExportIcsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>,
          TError,
          Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportIcsApiTodosExportIcsGet<TData = Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError = HTTPValidationError>(
 params?: ExportIcsApiTodosExportIcsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>,
          TError,
          Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportIcsApiTodosExportIcsGet<TData = Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError = HTTPValidationError>(
 params?: ExportIcsApiTodosExportIcsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Export Ics
 */

export function useExportIcsApiTodosExportIcsGet<TData = Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError = HTTPValidationError>(
 params?: ExportIcsApiTodosExportIcsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportIcsApiTodosExportIcsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExportIcsApiTodosExportIcsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ä»Ž ICS æ–‡ä»¶å¯¼å…¥ Todo
 * @summary Import Ics
 */
export const importIcsApiTodosImportIcsPost = (
    bodyImportIcsApiTodosImportIcsPost: BodyImportIcsApiTodosImportIcsPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyImportIcsApiTodosImportIcsPost.file)

      return customFetcher<TodoResponse[]>(
      {url: `/api/todos/import/ics`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getImportIcsApiTodosImportIcsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importIcsApiTodosImportIcsPost>>, TError,{data: BodyImportIcsApiTodosImportIcsPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof importIcsApiTodosImportIcsPost>>, TError,{data: BodyImportIcsApiTodosImportIcsPost}, TContext> => {

const mutationKey = ['importIcsApiTodosImportIcsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof importIcsApiTodosImportIcsPost>>, {data: BodyImportIcsApiTodosImportIcsPost}> = (props) => {
          const {data} = props ?? {};

          return  importIcsApiTodosImportIcsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImportIcsApiTodosImportIcsPostMutationResult = NonNullable<Awaited<ReturnType<typeof importIcsApiTodosImportIcsPost>>>
    export type ImportIcsApiTodosImportIcsPostMutationBody = BodyImportIcsApiTodosImportIcsPost
    export type ImportIcsApiTodosImportIcsPostMutationError = HTTPValidationError

    /**
 * @summary Import Ics
 */
export const useImportIcsApiTodosImportIcsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importIcsApiTodosImportIcsPost>>, TError,{data: BodyImportIcsApiTodosImportIcsPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof importIcsApiTodosImportIcsPost>>,
        TError,
        {data: BodyImportIcsApiTodosImportIcsPost},
        TContext
      > => {

      const mutationOptions = getImportIcsApiTodosImportIcsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    